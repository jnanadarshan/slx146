name: Extract Slide Tags

on:
  push:
    branches:
      - main
    paths:
      - 'slxv3.html'
  workflow_dispatch:

jobs:
  extract-tags:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug repository content
        run: |
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          
      - name: Check if HTML file exists
        id: check_file
        run: |
          # The checkout action should place us in the repository root
          # Use find command to locate the file anywhere in the repository
          FOUND_FILE=$(find $GITHUB_WORKSPACE -name "slxv3.html" -type f)
          
          if [ -z "$FOUND_FILE" ]; then
            echo "::error::slxv3.html file not found in repository!"
            exit 1
          else
            echo "Found HTML file at: $FOUND_FILE"
          fi

      - name: Extract tags from HTML
        id: extract
        run: |
          cat << 'EOF' > extract-tags.js
          const fs = require('fs');
          const path = require('path');

          // Configuration
          const htmlFilePath = path.join(__dirname, 'slxv3.html');
          const outputFilePath = path.join(__dirname, 'alltags.json');

          console.log(`Reading HTML file: ${htmlFilePath}`);
          console.log(`Output JSON file: ${outputFilePath}`);

          try {
              // Check if HTML file exists
              if (!fs.existsSync(htmlFilePath)) {
                  throw new Error(`HTML file not found at: ${htmlFilePath}`);
              }
              
              const htmlContent = fs.readFileSync(htmlFilePath, 'utf8');

              // Regex to find the 'const slideData = [...]' block
              const slideDataRegex = /const\s+slideData\s*=\s*(\[[\s\S]*?\]);/m;
              const match = htmlContent.match(slideDataRegex);

              if (!match || !match[1]) {
                  throw new Error('Could not find slideData array in the HTML file.');
              }

              let slideDataString = match[1];
              console.log('Successfully extracted slideData string.');

              // Parse the extracted string
              let slides = [];
              try {
                 const parseFunction = new Function(`return ${slideDataString};`);
                 slides = parseFunction();
                 console.log(`Successfully parsed ${slides.length} slide objects.`);
              } catch (parseError) {
                 console.error('Error parsing slideData string:', parseError);
                 throw new Error(`Failed to parse the extracted slideData array: ${parseError.message}`);
              }

              // Extract unique tags
              const allTags = new Set();
              let invalidTagsCount = 0;
              let slidesWithoutTags = 0;
              
              slides.forEach((slide, index) => {
                  if (slide && slide.tags && Array.isArray(slide.tags)) {
                      if (slide.tags.length === 0) {
                          slidesWithoutTags++;
                      }
                      
                      slide.tags.forEach(tag => {
                          if (typeof tag === 'string' && tag.trim() !== '') {
                              allTags.add(tag.trim());
                          } else if (tag !== undefined) {
                              invalidTagsCount++;
                              console.warn(`Found invalid tag in slide index ${index}:`, tag);
                          }
                      });
                  } else {
                      slidesWithoutTags++;
                      console.warn(`Slide index ${index} has missing or invalid tags array.`);
                  }
              });

              // Sort tags alphabetically
              const sortedTags = Array.from(allTags).sort((a, b) => a.localeCompare(b));

              // Write the sorted tags to the JSON file
              fs.writeFileSync(outputFilePath, JSON.stringify(sortedTags, null, 2));
              
              // Write summary info for GitHub Actions
              const summary = {
                totalSlides: slides.length,
                totalUniqueTags: sortedTags.length,
                slidesWithoutTags,
                invalidTagsCount
              };
              fs.writeFileSync('tag-extraction-summary.json', JSON.stringify(summary, null, 2));
              
              console.log(`Successfully extracted and saved ${sortedTags.length} unique tags to ${outputFilePath}`);
              console.log(`Slides: ${slides.length}, Unique tags: ${sortedTags.length}, Slides without tags: ${slidesWithoutTags}, Invalid tags: ${invalidTagsCount}`);

          } catch (error) {
              console.error('Error during tag extraction process:', error);
              process.exit(1);
          }
          EOF

          # Execute the script
          node extract-tags.js

      - name: Generate summary
        id: summary
        if: success()
        run: |
          if [ -f "tag-extraction-summary.json" ]; then
            echo "## Tag Extraction Summary" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Extraction completed successfully" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            cat tag-extraction-summary.json >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Commit and push alltags.json
        run: |
          # Only proceed if the file exists
          if [ ! -f "alltags.json" ]; then
            echo "::warning::alltags.json was not generated"
            exit 0
          fi
          
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add alltags.json
          
          # Check if there are changes staged for commit
          git diff --staged --quiet
          if [ $? -ne 0 ]; then
            echo "Changes detected in alltags.json. Committing..."
            # The [skip actions] flag prevents this commit from triggering another workflow run
            git commit -m "Update alltags.json [skip actions]"
            echo "Pushing changes..."
            git push
          else
            echo "No changes detected in alltags.json."
          fi

name: Extract Slide Tags

on:
  push:
    branches:
      - main
    paths:
      - 'slxv3.html'
  workflow_dispatch:

jobs:
  extract-tags:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug repository content
        run: |
          echo "Current directory: $(pwd)"
          echo "GitHub workspace: $GITHUB_WORKSPACE"
          echo "Directory contents:"
          ls -la
          echo "Finding slxv3.html:"
          find $GITHUB_WORKSPACE -type f -name "slxv3.html" || echo "File not found with find"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install required packages
        run: npm install -g jq-cli-wrapper

      - name: Create extraction script
        run: |
          cat << 'EOF' > extract-tags.js
          const fs = require('fs');
          const path = require('path');

          // Configuration
          const htmlFilePath = 'slxv3.html'; // Look in current directory
          const outputFilePath = 'alltags.json';

          console.log(`Node.js version: ${process.version}`);
          console.log(`Current working directory: ${process.cwd()}`);
          console.log(`Attempting to read HTML file: ${htmlFilePath}`);

          // Create empty tags file as initial fallback
          fs.writeFileSync(outputFilePath, JSON.stringify([]));

          try {
              // Check if HTML file exists
              if (!fs.existsSync(htmlFilePath)) {
                  console.error(`ERROR: HTML file not found at: ${htmlFilePath}`);
                  console.log('Directory contents:');
                  fs.readdirSync('.').forEach(file => {
                      console.log(`- ${file}`);
                  });
                  // Don't exit - we'll just return an empty array
                  console.log('Continuing with empty tags array');
                  return;
              }
              
              console.log(`File exists, size: ${fs.statSync(htmlFilePath).size} bytes`);
              
              // Read the HTML file
              const htmlContent = fs.readFileSync(htmlFilePath, 'utf8');
              console.log(`Successfully read HTML file, length: ${htmlContent.length} characters`);
              
              // Output first 200 characters for debugging
              console.log(`First 200 characters of HTML file:\n${htmlContent.substring(0, 200)}...`);

              // Regex to find the 'const slideData = [...]' block
              // Try multiple patterns to find the slideData
              const possibleRegexes = [
                /const\s+slideData\s*=\s*(\[[\s\S]*?\]);/m,
                /let\s+slideData\s*=\s*(\[[\s\S]*?\]);/m,
                /var\s+slideData\s*=\s*(\[[\s\S]*?\]);/m,
                /slideData\s*=\s*(\[[\s\S]*?\]);/m
              ];
              
              let match = null;
              let matchingPattern = null;
              
              for (const regex of possibleRegexes) {
                match = htmlContent.match(regex);
                if (match && match[1]) {
                  matchingPattern = regex.toString();
                  break;
                }
              }

              if (!match || !match[1]) {
                  console.error('Could not find slideData array in the HTML file.');
                  console.log('Searching for "slideData" keyword in the file:');
                  const slideDataIndex = htmlContent.indexOf('slideData');
                  
                  if (slideDataIndex > -1) {
                    console.log(`Found "slideData" at position ${slideDataIndex}`);
                    console.log(`Context around "slideData" (100 chars):\n${htmlContent.substring(Math.max(0, slideDataIndex - 50), slideDataIndex + 50)}`);
                  } else {
                    console.log(`"slideData" keyword not found in the file.`);
                  }
                  
                  // Already created empty file as fallback
                  return;
              }

              console.log(`Found slideData using pattern: ${matchingPattern}`);
              let slideDataString = match[1];
              console.log(`Successfully extracted slideData string. Length: ${slideDataString.length} characters`);
              console.log(`First 100 characters of slideData: ${slideDataString.substring(0, 100)}...`);

              // Parse the extracted string
              let slides = [];
              try {
                 const parseFunction = new Function(`return ${slideDataString};`);
                 slides = parseFunction();
                 console.log(`Successfully parsed ${slides.length} slide objects.`);
                 
                 // Debug first slide
                 if (slides.length > 0) {
                   console.log('First slide object keys:', Object.keys(slides[0]));
                   console.log('Sample slide:', JSON.stringify(slides[0]).substring(0, 200) + '...');
                 }
              } catch (parseError) {
                 console.error('Error parsing slideData string:', parseError.message);
                 console.log('Error details:', parseError.stack);
                 
                 // Already created empty file as fallback
                 return;
              }

              // Extract unique tags
              const allTags = new Set();
              let invalidTagsCount = 0;
              let slidesWithoutTags = 0;
              
              slides.forEach((slide, index) => {
                  if (slide && slide.tags && Array.isArray(slide.tags)) {
                      if (slide.tags.length === 0) {
                          slidesWithoutTags++;
                      }
                      
                      slide.tags.forEach(tag => {
                          if (typeof tag === 'string' && tag.trim() !== '') {
                              allTags.add(tag.trim());
                          } else if (tag !== undefined) {
                              invalidTagsCount++;
                              console.warn(`Found invalid tag in slide index ${index}:`, tag);
                          }
                      });
                  } else {
                      slidesWithoutTags++;
                      console.warn(`Slide index ${index} has missing or invalid tags array.`);
                  }
              });

              // Sort tags alphabetically
              const sortedTags = Array.from(allTags).sort((a, b) => a.localeCompare(b));

              // Write the sorted tags to the JSON file
              fs.writeFileSync(outputFilePath, JSON.stringify(sortedTags, null, 2));
              
              // Write summary info for GitHub Actions
              const summary = {
                totalSlides: slides.length,
                totalUniqueTags: sortedTags.length,
                slidesWithoutTags,
                invalidTagsCount
              };
              fs.writeFileSync('tag-extraction-summary.json', JSON.stringify(summary, null, 2));
              
              console.log(`Successfully extracted and saved ${sortedTags.length} unique tags to ${outputFilePath}`);
              console.log(`Slides: ${slides.length}, Unique tags: ${sortedTags.length}, Slides without tags: ${slidesWithoutTags}, Invalid tags: ${invalidTagsCount}`);

          } catch (error) {
              console.error('Error during tag extraction process:', error.message);
              console.error('Stack trace:', error.stack);
              
              // We already created an empty file as fallback at the beginning
              console.log('Using empty tags file as fallback');
          }
          EOF

      - name: Run extraction script
        id: extract
        run: node extract-tags.js 2>&1 | tee extraction-log.txt
        # Don't use "continue-on-error" - we've designed the script to not fail

      - name: Check extraction results
        id: check_results
        run: |
          echo "## Tag Extraction Process Log" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          cat extraction-log.txt >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          # Ensure alltags.json exists
          if [ ! -f "alltags.json" ]; then
            echo "Creating empty alltags.json as fallback"
            echo "[]" > alltags.json
            echo "⚠️ Created empty alltags.json as no tags were extracted" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ alltags.json was successfully generated" >> $GITHUB_STEP_SUMMARY
            
            # Count number of tags if jq is available
            if command -v jq >/dev/null 2>&1; then
              TAG_COUNT=$(jq length alltags.json)
              echo "Number of tags extracted: $TAG_COUNT" >> $GITHUB_STEP_SUMMARY
            else
              # Fallback if jq is not available
              TAG_COUNT=$(grep -o '"' alltags.json | wc -l)
              TAG_COUNT=$((TAG_COUNT / 2))
              echo "Approximate number of tags: $TAG_COUNT" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Show file stats
            FILE_SIZE=$(stat -c%s "alltags.json" || echo "unknown")
            echo "File size: $FILE_SIZE bytes" >> $GITHUB_STEP_SUMMARY
            
            # Show the content with proper formatting if possible
            echo "File content (first 1000 chars):" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            head -c 1000 alltags.json >> $GITHUB_STEP_SUMMARY
            if [ "$FILE_SIZE" -gt 1000 ]; then
              echo "..." >> $GITHUB_STEP_SUMMARY
            fi
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Commit and push alltags.json
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Always ensure the file exists before adding
          if [ ! -f "alltags.json" ]; then
            echo "[]" > alltags.json
            echo "Created empty alltags.json as a fallback"
          fi
          
          git add alltags.json
          
          # Check if there are changes staged for commit
          git diff --staged --quiet
          if [ $? -ne 0 ]; then
            echo "Changes detected in alltags.json. Committing..."
            # The [skip actions] flag prevents this commit from triggering another workflow run
            git commit -m "Update alltags.json [skip actions]"
            echo "Pushing changes..."
            git push
          else
            echo "No changes detected in alltags.json."
          fi
